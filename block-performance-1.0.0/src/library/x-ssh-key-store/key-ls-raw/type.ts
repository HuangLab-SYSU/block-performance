// auto generated by dev/system

import { Logger } from "../../../myutils/logger.js";

export interface Input {
    sort?: {
        field_list: {
            id?: { order: "ascending" | "descending" };
            fake?: { order: "ascending" | "descending" };
            create_time?: { order: "ascending" | "descending" };
            update_time?: { order: "ascending" | "descending" };
            username?: { order: "ascending" | "descending" };
            address_list?: { index: number; item: { order: "ascending" | "descending" } };
            tag_list?: { index: number; item: { order: "ascending" | "descending" } };
            private_key?: { order: "ascending" | "descending" };
            disabled?: { order: "ascending" | "descending" };
        }[];
    };
    page?: { offset: number; limit: number };
}

export interface OutputEmpty {
    list: {
        id: string;
        fake?: boolean;
        create_time: string;
        update_time: string;
        username: string;
        address_list: string[];
        tag_list: string[];
        private_key: string;
        disabled: boolean;
    }[];
    total_count: number;
}

export interface OutputOk {
    list: {
        id: string;
        fake?: boolean;
        create_time: string;
        update_time: string;
        username: string;
        address_list: string[];
        tag_list: string[];
        private_key: string;
        disabled: boolean;
    }[];
    total_count: number;
}

export interface OutputFail {}

export interface Callback<R> {
    empty: (output: OutputEmpty) => R;
    ok: (output: OutputOk) => R;
    fail: (err: Error) => R;
}

export function check_input<R>(plog: Logger, v: any, cb: { ok: () => R; fail: (err: Error) => R }): R {
    const log = plog.sub("check_input");
    log.variable("v", v);
    try {
        log.println("v must be object");
        if (typeof v !== "object" || v === null) {
            throw new Error("v is not object");
        }

        Object.keys(v).forEach((field) => {
            if (field === "sort") return;
            if (field === "page") return;
            throw new Error("v contains unknown field: " + field);
        });

        if (v.sort !== undefined) {
            log.println("v.sort must be object");
            if (typeof v.sort !== "object" || v.sort === null) {
                throw new Error("v.sort is not object");
            }

            Object.keys(v.sort).forEach((field) => {
                if (field === "field_list") return;
                throw new Error("v.sort contains unknown field: " + field);
            });

            log.println("v.sort.field_list must be array");
            if (!Array.isArray(v.sort.field_list)) {
                throw new Error("v.sort.field_list is not array");
            }

            v.sort.field_list.forEach((item: any, i: number) => {
                log.println("check v.sort.field_list[i]");

                log.println("item must be object");
                if (typeof item !== "object" || item === null) {
                    throw new Error("item is not object");
                }

                Object.keys(item).forEach((field) => {
                    if (field === "id") return;
                    if (field === "fake") return;
                    if (field === "create_time") return;
                    if (field === "update_time") return;
                    if (field === "username") return;
                    if (field === "address_list") return;
                    if (field === "tag_list") return;
                    if (field === "private_key") return;
                    if (field === "disabled") return;
                    throw new Error("item contains unknown field: " + field);
                });

                if (item.id !== undefined) {
                    log.println("item.id must be object");
                    if (typeof item.id !== "object" || item.id === null) {
                        throw new Error("item.id is not object");
                    }

                    Object.keys(item.id).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.id contains unknown field: " + field);
                    });

                    log.println("item.id.order must be string");
                    if (typeof item.id.order !== "string") {
                        throw new Error("item.id.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.id.order) === false) {
                        throw new Error("item.id.order is not a valid string enum value");
                    }
                }

                if (item.fake !== undefined) {
                    log.println("item.fake must be object");
                    if (typeof item.fake !== "object" || item.fake === null) {
                        throw new Error("item.fake is not object");
                    }

                    Object.keys(item.fake).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.fake contains unknown field: " + field);
                    });

                    log.println("item.fake.order must be string");
                    if (typeof item.fake.order !== "string") {
                        throw new Error("item.fake.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.fake.order) === false) {
                        throw new Error("item.fake.order is not a valid string enum value");
                    }
                }

                if (item.create_time !== undefined) {
                    log.println("item.create_time must be object");
                    if (typeof item.create_time !== "object" || item.create_time === null) {
                        throw new Error("item.create_time is not object");
                    }

                    Object.keys(item.create_time).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.create_time contains unknown field: " + field);
                    });

                    log.println("item.create_time.order must be string");
                    if (typeof item.create_time.order !== "string") {
                        throw new Error("item.create_time.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.create_time.order) === false) {
                        throw new Error("item.create_time.order is not a valid string enum value");
                    }
                }

                if (item.update_time !== undefined) {
                    log.println("item.update_time must be object");
                    if (typeof item.update_time !== "object" || item.update_time === null) {
                        throw new Error("item.update_time is not object");
                    }

                    Object.keys(item.update_time).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.update_time contains unknown field: " + field);
                    });

                    log.println("item.update_time.order must be string");
                    if (typeof item.update_time.order !== "string") {
                        throw new Error("item.update_time.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.update_time.order) === false) {
                        throw new Error("item.update_time.order is not a valid string enum value");
                    }
                }

                if (item.username !== undefined) {
                    log.println("item.username must be object");
                    if (typeof item.username !== "object" || item.username === null) {
                        throw new Error("item.username is not object");
                    }

                    Object.keys(item.username).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.username contains unknown field: " + field);
                    });

                    log.println("item.username.order must be string");
                    if (typeof item.username.order !== "string") {
                        throw new Error("item.username.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.username.order) === false) {
                        throw new Error("item.username.order is not a valid string enum value");
                    }
                }

                if (item.address_list !== undefined) {
                    log.println("item.address_list must be object");
                    if (typeof item.address_list !== "object" || item.address_list === null) {
                        throw new Error("item.address_list is not object");
                    }

                    Object.keys(item.address_list).forEach((field) => {
                        if (field === "index") return;
                        if (field === "item") return;
                        throw new Error("item.address_list contains unknown field: " + field);
                    });

                    log.println("item.address_list.index must be number");
                    if (typeof item.address_list.index !== "number") {
                        throw new Error("item.address_list.index is not number");
                    }

                    if (Number.isSafeInteger(item.address_list.index) === false) {
                        throw new Error("item.address_list.index is not safe integer");
                    }

                    if ((item.address_list.index >= 0 && item.address_list.index < 9007199254740991) === false) {
                        throw new Error("item.address_list.index is out of range");
                    }

                    log.println("item.address_list.item must be object");
                    if (typeof item.address_list.item !== "object" || item.address_list.item === null) {
                        throw new Error("item.address_list.item is not object");
                    }

                    Object.keys(item.address_list.item).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.address_list.item contains unknown field: " + field);
                    });

                    log.println("item.address_list.item.order must be string");
                    if (typeof item.address_list.item.order !== "string") {
                        throw new Error("item.address_list.item.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.address_list.item.order) === false) {
                        throw new Error("item.address_list.item.order is not a valid string enum value");
                    }
                }

                if (item.tag_list !== undefined) {
                    log.println("item.tag_list must be object");
                    if (typeof item.tag_list !== "object" || item.tag_list === null) {
                        throw new Error("item.tag_list is not object");
                    }

                    Object.keys(item.tag_list).forEach((field) => {
                        if (field === "index") return;
                        if (field === "item") return;
                        throw new Error("item.tag_list contains unknown field: " + field);
                    });

                    log.println("item.tag_list.index must be number");
                    if (typeof item.tag_list.index !== "number") {
                        throw new Error("item.tag_list.index is not number");
                    }

                    if (Number.isSafeInteger(item.tag_list.index) === false) {
                        throw new Error("item.tag_list.index is not safe integer");
                    }

                    if ((item.tag_list.index >= 0 && item.tag_list.index < 9007199254740991) === false) {
                        throw new Error("item.tag_list.index is out of range");
                    }

                    log.println("item.tag_list.item must be object");
                    if (typeof item.tag_list.item !== "object" || item.tag_list.item === null) {
                        throw new Error("item.tag_list.item is not object");
                    }

                    Object.keys(item.tag_list.item).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.tag_list.item contains unknown field: " + field);
                    });

                    log.println("item.tag_list.item.order must be string");
                    if (typeof item.tag_list.item.order !== "string") {
                        throw new Error("item.tag_list.item.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.tag_list.item.order) === false) {
                        throw new Error("item.tag_list.item.order is not a valid string enum value");
                    }
                }

                if (item.private_key !== undefined) {
                    log.println("item.private_key must be object");
                    if (typeof item.private_key !== "object" || item.private_key === null) {
                        throw new Error("item.private_key is not object");
                    }

                    Object.keys(item.private_key).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.private_key contains unknown field: " + field);
                    });

                    log.println("item.private_key.order must be string");
                    if (typeof item.private_key.order !== "string") {
                        throw new Error("item.private_key.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.private_key.order) === false) {
                        throw new Error("item.private_key.order is not a valid string enum value");
                    }
                }

                if (item.disabled !== undefined) {
                    log.println("item.disabled must be object");
                    if (typeof item.disabled !== "object" || item.disabled === null) {
                        throw new Error("item.disabled is not object");
                    }

                    Object.keys(item.disabled).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.disabled contains unknown field: " + field);
                    });

                    log.println("item.disabled.order must be string");
                    if (typeof item.disabled.order !== "string") {
                        throw new Error("item.disabled.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.disabled.order) === false) {
                        throw new Error("item.disabled.order is not a valid string enum value");
                    }
                }
            });
        }

        if (v.page !== undefined) {
            log.println("v.page must be object");
            if (typeof v.page !== "object" || v.page === null) {
                throw new Error("v.page is not object");
            }

            Object.keys(v.page).forEach((field) => {
                if (field === "offset") return;
                if (field === "limit") return;
                throw new Error("v.page contains unknown field: " + field);
            });

            log.println("v.page.offset must be number");
            if (typeof v.page.offset !== "number") {
                throw new Error("v.page.offset is not number");
            }

            if (Number.isSafeInteger(v.page.offset) === false) {
                throw new Error("v.page.offset is not safe integer");
            }

            if ((v.page.offset >= 0 && v.page.offset < 9007199254740991) === false) {
                throw new Error("v.page.offset is out of range");
            }

            log.println("v.page.limit must be number");
            if (typeof v.page.limit !== "number") {
                throw new Error("v.page.limit is not number");
            }

            if (Number.isSafeInteger(v.page.limit) === false) {
                throw new Error("v.page.limit is not safe integer");
            }

            if ((v.page.limit >= 0 && v.page.limit < 9007199254740991) === false) {
                throw new Error("v.page.limit is out of range");
            }
        }
    } catch (err) {
        log.error(err);
        return cb.fail(err);
    }
    // nothing wrong
    log.ok();
    return cb.ok();
}

// JSON stringify value before copy to handle some specific problem
// eg. Date Object probelm
export function copy_output_empty(v: any): OutputEmpty {
    if (v !== undefined) {
        const v_cloned = JSON.parse(JSON.stringify(v));
        return _copy_output_empty(v_cloned);
    } else {
        return _copy_output_empty(v);
    }
}

export function _copy_output_empty(v: any): OutputEmpty {
    if (typeof v === "object" && v !== null) {
        const obj = {
            list: copy_list(v.list),
            total_count: copy_total_count(v.total_count)
        };
        return obj;
    } else {
        return { list: [], total_count: 0 };
    }

    function copy_list(
        v: any
    ): {
        id: string;
        fake?: boolean;
        create_time: string;
        update_time: string;
        username: string;
        address_list: string[];
        tag_list: string[];
        private_key: string;
        disabled: boolean;
    }[] {
        return Array.isArray(v) ? v.map(copy_item) : [];

        function copy_item(v: any): {
            id: string;
            fake?: boolean;
            create_time: string;
            update_time: string;
            username: string;
            address_list: string[];
            tag_list: string[];
            private_key: string;
            disabled: boolean;
        } {
            if (typeof v === "object" && v !== null) {
                const obj = {
                    id: copy_id(v.id),
                    fake: v.fake !== undefined && v.fake !== null ? copy_fake(v.fake) : undefined,
                    create_time: copy_create_time(v.create_time),
                    update_time: copy_update_time(v.update_time),
                    username: copy_username(v.username),
                    address_list: copy_address_list(v.address_list),
                    tag_list: copy_tag_list(v.tag_list),
                    private_key: copy_private_key(v.private_key),
                    disabled: copy_disabled(v.disabled)
                };
                return obj;
            } else {
                return { id: "", create_time: "", update_time: "", username: "", address_list: [], tag_list: [], private_key: "", disabled: false };
            }

            function copy_id(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_fake(v: any): boolean {
                return typeof v === "boolean" ? v : false;
            }

            function copy_create_time(v: any): string {
                // empty datetime value is acceptable
                if (typeof v !== "string") {
                    return "";
                } else {
                    if (v === "") {
                        return v;
                    } else if (Number.isNaN(Date.parse(v)) === false) {
                        return v;
                    } else {
                        // invalid value, return empty string
                        return "";
                    }
                }
            }

            function copy_update_time(v: any): string {
                // empty datetime value is acceptable
                if (typeof v !== "string") {
                    return "";
                } else {
                    if (v === "") {
                        return v;
                    } else if (Number.isNaN(Date.parse(v)) === false) {
                        return v;
                    } else {
                        // invalid value, return empty string
                        return "";
                    }
                }
            }

            function copy_username(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_address_list(v: any): string[] {
                return Array.isArray(v) ? v.map(copy_item) : [];

                function copy_item(v: any): string {
                    return typeof v === "string" ? v : "";
                }
            }

            function copy_tag_list(v: any): string[] {
                return Array.isArray(v) ? v.map(copy_item) : [];

                function copy_item(v: any): string {
                    return typeof v === "string" ? v : "";
                }
            }

            function copy_private_key(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_disabled(v: any): boolean {
                return typeof v === "boolean" ? v : false;
            }
        }
    }

    function copy_total_count(v: any): number {
        return typeof v === "number" ? v : 0;
    }
}

// JSON stringify value before copy to handle some specific problem
// eg. Date Object probelm
export function copy_output_ok(v: any): OutputOk {
    if (v !== undefined) {
        const v_cloned = JSON.parse(JSON.stringify(v));
        return _copy_output_ok(v_cloned);
    } else {
        return _copy_output_ok(v);
    }
}

export function _copy_output_ok(v: any): OutputOk {
    if (typeof v === "object" && v !== null) {
        const obj = {
            list: copy_list(v.list),
            total_count: copy_total_count(v.total_count)
        };
        return obj;
    } else {
        return { list: [], total_count: 0 };
    }

    function copy_list(
        v: any
    ): {
        id: string;
        fake?: boolean;
        create_time: string;
        update_time: string;
        username: string;
        address_list: string[];
        tag_list: string[];
        private_key: string;
        disabled: boolean;
    }[] {
        return Array.isArray(v) ? v.map(copy_item) : [];

        function copy_item(v: any): {
            id: string;
            fake?: boolean;
            create_time: string;
            update_time: string;
            username: string;
            address_list: string[];
            tag_list: string[];
            private_key: string;
            disabled: boolean;
        } {
            if (typeof v === "object" && v !== null) {
                const obj = {
                    id: copy_id(v.id),
                    fake: v.fake !== undefined && v.fake !== null ? copy_fake(v.fake) : undefined,
                    create_time: copy_create_time(v.create_time),
                    update_time: copy_update_time(v.update_time),
                    username: copy_username(v.username),
                    address_list: copy_address_list(v.address_list),
                    tag_list: copy_tag_list(v.tag_list),
                    private_key: copy_private_key(v.private_key),
                    disabled: copy_disabled(v.disabled)
                };
                return obj;
            } else {
                return { id: "", create_time: "", update_time: "", username: "", address_list: [], tag_list: [], private_key: "", disabled: false };
            }

            function copy_id(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_fake(v: any): boolean {
                return typeof v === "boolean" ? v : false;
            }

            function copy_create_time(v: any): string {
                // empty datetime value is acceptable
                if (typeof v !== "string") {
                    return "";
                } else {
                    if (v === "") {
                        return v;
                    } else if (Number.isNaN(Date.parse(v)) === false) {
                        return v;
                    } else {
                        // invalid value, return empty string
                        return "";
                    }
                }
            }

            function copy_update_time(v: any): string {
                // empty datetime value is acceptable
                if (typeof v !== "string") {
                    return "";
                } else {
                    if (v === "") {
                        return v;
                    } else if (Number.isNaN(Date.parse(v)) === false) {
                        return v;
                    } else {
                        // invalid value, return empty string
                        return "";
                    }
                }
            }

            function copy_username(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_address_list(v: any): string[] {
                return Array.isArray(v) ? v.map(copy_item) : [];

                function copy_item(v: any): string {
                    return typeof v === "string" ? v : "";
                }
            }

            function copy_tag_list(v: any): string[] {
                return Array.isArray(v) ? v.map(copy_item) : [];

                function copy_item(v: any): string {
                    return typeof v === "string" ? v : "";
                }
            }

            function copy_private_key(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_disabled(v: any): boolean {
                return typeof v === "boolean" ? v : false;
            }
        }
    }

    function copy_total_count(v: any): number {
        return typeof v === "number" ? v : 0;
    }
}

// backward compatible purpose
export type Output = OutputOk;
export const copy_output = copy_output_ok;
