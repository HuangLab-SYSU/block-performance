// auto generated by dev/system

import { Logger, set_logger_disabled } from "../../../myutils/logger.js";
import { prompts } from "../../../myutils/index.js";
import { read_json_file } from "../../../myutils/node/file/index.js";
import { Input, Output, check_input, OutputOk } from "./type.js";
import { instance_create as target_fun } from "./export.js";
import { rpc_instance_create as rpc_target_fun } from "./rpc/client.js";
import yargs from "yargs";

const log = new Logger("cli");
run();

async function run() {
    try {
        const { input, server } = await make_input(log, {
            ok: async (input: Input, server) => {
                return { input, server };
            },
            fail: async (err) => {
                throw err;
            }
        });

        if (server) {
            await rpc_target_fun(
                log,
                {
                    server,
                    input
                },
                {
                    ok: (output) => {
                        console.log(JSON.stringify(output, null, 4));
                        console.log("ðŸ˜„ ok");
                    },

                    fail: (err) => {
                        throw err;
                    }
                }
            );
        } else {
            await target_fun(log, input, {
                ok: (output: OutputOk) => {
                    console.log(JSON.stringify(output, null, 4));
                    console.log("ðŸ˜„ ok");
                },

                fail: (err) => {
                    throw err;
                }
            });
        }
    } catch (err) {
        log.print_unknown_error(err);
        console.log("ðŸ˜¢ fail.");
    }
}

async function make_input<R>(
    plog: Logger,
    cb: {
        ok: (input: Input, rpc_server: string) => R;
        fail: (err: Error) => R;
    }
): Promise<R> {
    const log = plog.sub("make_input");

    const args = await yargs(process.argv.slice(2))
        .option("input", {
            type: "string",
            description: "Specify the JSON input directly as a command line argument."
        })
        .option("input-file", {
            type: "string",
            description: "Specify the name of a JSON file to read input from."
        })
        .option("server", {
            type: "string",
            description: "Specify the URL of a remote server to send the request to."
        })
        .option("logger-disabled", {
            type: "boolean",
            description: "Disable logging completely."
        })
        .parse();

    const input = args.input || process.env["x_input"];
    const input_file = args.inputFile || process.env["x_input_file"];
    const server = args.server || process.env["x_server"];
    const logger_disabled = args.loggerDisabled || process.env["x_logger_disabled"] === "true";

    if (logger_disabled) {
        set_logger_disabled(true);
    }

    log.variable("input", input);
    log.variable("input_file", input_file);
    log.variable("server", server);
    log.variable("logger_disabled", logger_disabled);

    if (input && input_file) {
        return cb.fail(log.new_error("Conflicting arguments provided. You can use either --input or --input-file, but not both at the same time."));
    }

    if (input) {
        return make_input_from_args(
            log,
            { json_text: input },
            {
                ok: (input) => {
                    return cb.ok(input, server);
                },
                fail: (err) => {
                    return cb.fail(err);
                }
            }
        );
    } else if (input_file) {
        return make_input_from_file(
            log,
            { filename: input_file },
            {
                ok: (input) => {
                    return cb.ok(input, server);
                },
                fail: (err) => {
                    return cb.fail(err);
                }
            }
        );
    } else {
        return make_input_from_prompts(log, {
            ok: (input) => {
                return cb.ok(input, server);
            },
            fail: (err) => {
                return cb.fail(err);
            }
        });
    }
}

async function make_input_from_args<R>(
    plog: Logger,
    opts: { json_text: string },
    cb: {
        ok: (input: Input) => R;
        fail: (err: Error) => R;
    }
): Promise<R> {
    const log = plog.sub("make_input_from_args");
    try {
        const input = JSON.parse(opts.json_text);
        log.variable("input", input);

        return check_input(log, input, {
            ok: () => {
                return cb.ok(input);
            },
            fail: (err) => {
                return cb.fail(err);
            }
        });
    } catch (err) {
        log.print_unknown_error(err);
        return cb.fail(err);
    }
}

async function make_input_from_file<R>(
    plog: Logger,
    opts: { filename: string },
    cb: {
        ok: (input: Input) => R;
        fail: (err: Error) => R;
    }
): Promise<R> {
    const log = plog.sub("make_input_from_file");
    return read_json_file(log, opts.filename, {
        ok: (input) => {
            return check_input(log, input, {
                ok: () => {
                    return cb.ok(input);
                },
                fail: (err) => {
                    return cb.fail(err);
                }
            });
        },
        fail: (err) => {
            return cb.fail(err);
        }
    });
}

async function make_input_from_prompts<R>(
    plog: Logger,
    cb: {
        ok: (v: {
            credentials: { accessKeyId: string; secretAccessKey: string };
            instanceName: string;
            region: string;
            availabilityZone?: string;
            blueprintId: string;
            bundleId: string;
            userData?: string;
            tags?: { key: string; value: string }[];
            openPorts?: {
                protocol: "all" | "tcp" | "udp" | "icmp";
                fromPort: number;
                toPort: number;
                cidrs: string[];
                ipv6Cidrs: string[];
                cidrListAliases: string[];
            }[];
        }) => R;
        fail: (err: Error) => R;
    }
): Promise<R> {
    const log = plog.sub("make_input_from_prompts");
    try {
        var v: {
            credentials: { accessKeyId: string; secretAccessKey: string };
            instanceName: string;
            region: string;
            availabilityZone?: string;
            blueprintId: string;
            bundleId: string;
            userData?: string;
            tags?: { key: string; value: string }[];
            openPorts?: {
                protocol: "all" | "tcp" | "udp" | "icmp";
                fromPort: number;
                toPort: number;
                cidrs: string[];
                ipv6Cidrs: string[];
                cidrListAliases: string[];
            }[];
        } = {
            credentials: await input_credentials(log.sub("credentials"), {
                ok: (v) => v,
                fail: (err) => {
                    throw err;
                }
            }),
            instanceName: await input_instanceName(log.sub("instanceName"), {
                ok: (v) => v,
                fail: (err) => {
                    throw err;
                }
            }),
            region: await input_region(log.sub("region"), {
                ok: (v) => v,
                fail: (err) => {
                    throw err;
                }
            }),
            availabilityZone: await skip_or_input("availabilityZone", () =>
                input_availabilityZone(log.sub("availabilityZone"), {
                    ok: (v) => v,
                    fail: (err) => {
                        throw err;
                    }
                })
            ),
            blueprintId: await input_blueprintId(log.sub("blueprintId"), {
                ok: (v) => v,
                fail: (err) => {
                    throw err;
                }
            }),
            bundleId: await input_bundleId(log.sub("bundleId"), {
                ok: (v) => v,
                fail: (err) => {
                    throw err;
                }
            }),
            userData: await skip_or_input("userData", () =>
                input_userData(log.sub("userData"), {
                    ok: (v) => v,
                    fail: (err) => {
                        throw err;
                    }
                })
            ),
            tags: await skip_or_input("tags", () =>
                input_tags(log.sub("tags"), {
                    ok: (v) => v,
                    fail: (err) => {
                        throw err;
                    }
                })
            ),
            openPorts: await skip_or_input("openPorts", () =>
                input_openPorts(log.sub("openPorts"), {
                    ok: (v) => v,
                    fail: (err) => {
                        throw err;
                    }
                })
            )
        };
    } catch (err) {
        log.error(err);
        return cb.fail(err);
    }

    return cb.ok(v);

    async function input_credentials<R>(
        plog: Logger,
        cb: { ok: (v: { accessKeyId: string; secretAccessKey: string }) => R; fail: (err: Error) => R }
    ): Promise<R> {
        const log = plog.sub("input_credentials");
        try {
            var v: { accessKeyId: string; secretAccessKey: string } = {
                accessKeyId: await input_accessKeyId(log.sub("accessKeyId"), {
                    ok: (v) => v,
                    fail: (err) => {
                        throw err;
                    }
                }),
                secretAccessKey: await input_secretAccessKey(log.sub("secretAccessKey"), {
                    ok: (v) => v,
                    fail: (err) => {
                        throw err;
                    }
                })
            };
        } catch (err) {
            log.error(err);
            return cb.fail(err);
        }

        return cb.ok(v);

        async function input_accessKeyId<R>(plog: Logger, cb: { ok: (v: string) => R; fail: (err: Error) => R }): Promise<R> {
            const log = plog.sub("input_accessKeyId");
            // FIXME implement all string constrains here
            const v = await prompts.input_string("accessKeyId", { allow_empty: true });
            return cb.ok(v);
        }

        async function input_secretAccessKey<R>(plog: Logger, cb: { ok: (v: string) => R; fail: (err: Error) => R }): Promise<R> {
            const log = plog.sub("input_secretAccessKey");
            // FIXME implement all string constrains here
            const v = await prompts.input_string("secretAccessKey", { allow_empty: true });
            return cb.ok(v);
        }
    }

    async function input_instanceName<R>(plog: Logger, cb: { ok: (v: string) => R; fail: (err: Error) => R }): Promise<R> {
        const log = plog.sub("input_instanceName");
        // FIXME implement all string constrains here
        const v = await prompts.input_string("instanceName", { allow_empty: true });
        return cb.ok(v);
    }

    async function input_region<R>(plog: Logger, cb: { ok: (v: string) => R; fail: (err: Error) => R }): Promise<R> {
        const log = plog.sub("input_region");
        // FIXME implement all string constrains here
        const v = await prompts.input_string("region", { allow_empty: true });
        return cb.ok(v);
    }

    async function input_availabilityZone<R>(plog: Logger, cb: { ok: (v: string) => R; fail: (err: Error) => R }): Promise<R> {
        const log = plog.sub("input_availabilityZone");
        // FIXME implement all string constrains here
        const v = await prompts.input_string("availabilityZone", { allow_empty: true });
        return cb.ok(v);
    }

    async function input_blueprintId<R>(plog: Logger, cb: { ok: (v: string) => R; fail: (err: Error) => R }): Promise<R> {
        const log = plog.sub("input_blueprintId");
        // FIXME implement all string constrains here
        const v = await prompts.input_string("blueprintId", { allow_empty: true });
        return cb.ok(v);
    }

    async function input_bundleId<R>(plog: Logger, cb: { ok: (v: string) => R; fail: (err: Error) => R }): Promise<R> {
        const log = plog.sub("input_bundleId");
        // FIXME implement all string constrains here
        const v = await prompts.input_string("bundleId", { allow_empty: true });
        return cb.ok(v);
    }

    async function input_userData<R>(plog: Logger, cb: { ok: (v: string) => R; fail: (err: Error) => R }): Promise<R> {
        const log = plog.sub("input_userData");
        // FIXME implement all string constrains here
        const v = await prompts.input_string("userData", { allow_empty: true });
        return cb.ok(v);
    }

    async function input_tags<R>(plog: Logger, cb: { ok: (v: { key: string; value: string }[]) => R; fail: (err: Error) => R }): Promise<R> {
        const log = plog.sub("input_tags");
        const length = await prompts.input_number("(array.length) tags");
        const list: { key: string; value: string }[] = [];
        for (let i = 0; i < length; ++i) {
            const err = await input_item(log, {
                ok: (item) => {
                    list.push(item);
                    return null;
                },
                fail: (err) => {
                    return err;
                }
            });

            if (err) {
                return cb.fail(err);
            }
        }

        return cb.ok(list);

        async function input_item<R>(plog: Logger, cb: { ok: (v: { key: string; value: string }) => R; fail: (err: Error) => R }): Promise<R> {
            const log = plog.sub("input_item");
            try {
                var v: { key: string; value: string } = {
                    key: await input_key(log.sub("key"), {
                        ok: (v) => v,
                        fail: (err) => {
                            throw err;
                        }
                    }),
                    value: await input_value(log.sub("value"), {
                        ok: (v) => v,
                        fail: (err) => {
                            throw err;
                        }
                    })
                };
            } catch (err) {
                log.error(err);
                return cb.fail(err);
            }

            return cb.ok(v);

            async function input_key<R>(plog: Logger, cb: { ok: (v: string) => R; fail: (err: Error) => R }): Promise<R> {
                const log = plog.sub("input_key");
                // FIXME implement all string constrains here
                const v = await prompts.input_string("key", { allow_empty: true });
                return cb.ok(v);
            }

            async function input_value<R>(plog: Logger, cb: { ok: (v: string) => R; fail: (err: Error) => R }): Promise<R> {
                const log = plog.sub("input_value");
                // FIXME implement all string constrains here
                const v = await prompts.input_string("value", { allow_empty: true });
                return cb.ok(v);
            }
        }
    }

    async function input_openPorts<R>(
        plog: Logger,
        cb: {
            ok: (
                v: {
                    protocol: "all" | "tcp" | "udp" | "icmp";
                    fromPort: number;
                    toPort: number;
                    cidrs: string[];
                    ipv6Cidrs: string[];
                    cidrListAliases: string[];
                }[]
            ) => R;
            fail: (err: Error) => R;
        }
    ): Promise<R> {
        const log = plog.sub("input_openPorts");
        const length = await prompts.input_number("(array.length) openPorts");
        const list: {
            protocol: "all" | "tcp" | "udp" | "icmp";
            fromPort: number;
            toPort: number;
            cidrs: string[];
            ipv6Cidrs: string[];
            cidrListAliases: string[];
        }[] = [];
        for (let i = 0; i < length; ++i) {
            const err = await input_item(log, {
                ok: (item) => {
                    list.push(item);
                    return null;
                },
                fail: (err) => {
                    return err;
                }
            });

            if (err) {
                return cb.fail(err);
            }
        }

        return cb.ok(list);

        async function input_item<R>(
            plog: Logger,
            cb: {
                ok: (v: {
                    protocol: "all" | "tcp" | "udp" | "icmp";
                    fromPort: number;
                    toPort: number;
                    cidrs: string[];
                    ipv6Cidrs: string[];
                    cidrListAliases: string[];
                }) => R;
                fail: (err: Error) => R;
            }
        ): Promise<R> {
            const log = plog.sub("input_item");
            try {
                var v: {
                    protocol: "all" | "tcp" | "udp" | "icmp";
                    fromPort: number;
                    toPort: number;
                    cidrs: string[];
                    ipv6Cidrs: string[];
                    cidrListAliases: string[];
                } = {
                    protocol: await input_protocol(log.sub("protocol"), {
                        ok: (v) => v,
                        fail: (err) => {
                            throw err;
                        }
                    }),
                    fromPort: await input_fromPort(log.sub("fromPort"), {
                        ok: (v) => v,
                        fail: (err) => {
                            throw err;
                        }
                    }),
                    toPort: await input_toPort(log.sub("toPort"), {
                        ok: (v) => v,
                        fail: (err) => {
                            throw err;
                        }
                    }),
                    cidrs: await input_cidrs(log.sub("cidrs"), {
                        ok: (v) => v,
                        fail: (err) => {
                            throw err;
                        }
                    }),
                    ipv6Cidrs: await input_ipv6Cidrs(log.sub("ipv6Cidrs"), {
                        ok: (v) => v,
                        fail: (err) => {
                            throw err;
                        }
                    }),
                    cidrListAliases: await input_cidrListAliases(log.sub("cidrListAliases"), {
                        ok: (v) => v,
                        fail: (err) => {
                            throw err;
                        }
                    })
                };
            } catch (err) {
                log.error(err);
                return cb.fail(err);
            }

            return cb.ok(v);

            async function input_protocol<R>(plog: Logger, cb: { ok: (v: "all" | "tcp" | "udp" | "icmp") => R; fail: (err: Error) => R }): Promise<R> {
                const log = plog.sub("input_protocol");
                // FIXME implement all string constrains here
                const v: "all" | "tcp" | "udp" | "icmp" = await prompts.input_string_enum("protocol", ["all", "tcp", "udp", "icmp"]);
                return cb.ok(v);
            }

            async function input_fromPort<R>(plog: Logger, cb: { ok: (v: number) => R; fail: (err: Error) => R }): Promise<R> {
                const log = plog.sub("input_fromPort");
                // FIXME implement all number constrains here
                const v = await prompts.input_number("fromPort");
                return cb.ok(v);
            }

            async function input_toPort<R>(plog: Logger, cb: { ok: (v: number) => R; fail: (err: Error) => R }): Promise<R> {
                const log = plog.sub("input_toPort");
                // FIXME implement all number constrains here
                const v = await prompts.input_number("toPort");
                return cb.ok(v);
            }

            async function input_cidrs<R>(plog: Logger, cb: { ok: (v: string[]) => R; fail: (err: Error) => R }): Promise<R> {
                const log = plog.sub("input_cidrs");
                const length = await prompts.input_number("(array.length) cidrs");
                const list: string[] = [];
                for (let i = 0; i < length; ++i) {
                    const err = await input_item(log, {
                        ok: (item) => {
                            list.push(item);
                            return null;
                        },
                        fail: (err) => {
                            return err;
                        }
                    });

                    if (err) {
                        return cb.fail(err);
                    }
                }

                return cb.ok(list);

                async function input_item<R>(plog: Logger, cb: { ok: (v: string) => R; fail: (err: Error) => R }): Promise<R> {
                    const log = plog.sub("input_item");
                    // FIXME implement all string constrains here
                    const v = await prompts.input_string("", { allow_empty: true });
                    return cb.ok(v);
                }
            }

            async function input_ipv6Cidrs<R>(plog: Logger, cb: { ok: (v: string[]) => R; fail: (err: Error) => R }): Promise<R> {
                const log = plog.sub("input_ipv6Cidrs");
                const length = await prompts.input_number("(array.length) ipv6Cidrs");
                const list: string[] = [];
                for (let i = 0; i < length; ++i) {
                    const err = await input_item(log, {
                        ok: (item) => {
                            list.push(item);
                            return null;
                        },
                        fail: (err) => {
                            return err;
                        }
                    });

                    if (err) {
                        return cb.fail(err);
                    }
                }

                return cb.ok(list);

                async function input_item<R>(plog: Logger, cb: { ok: (v: string) => R; fail: (err: Error) => R }): Promise<R> {
                    const log = plog.sub("input_item");
                    // FIXME implement all string constrains here
                    const v = await prompts.input_string("", { allow_empty: true });
                    return cb.ok(v);
                }
            }

            async function input_cidrListAliases<R>(plog: Logger, cb: { ok: (v: string[]) => R; fail: (err: Error) => R }): Promise<R> {
                const log = plog.sub("input_cidrListAliases");
                const length = await prompts.input_number("(array.length) cidrListAliases");
                const list: string[] = [];
                for (let i = 0; i < length; ++i) {
                    const err = await input_item(log, {
                        ok: (item) => {
                            list.push(item);
                            return null;
                        },
                        fail: (err) => {
                            return err;
                        }
                    });

                    if (err) {
                        return cb.fail(err);
                    }
                }

                return cb.ok(list);

                async function input_item<R>(plog: Logger, cb: { ok: (v: string) => R; fail: (err: Error) => R }): Promise<R> {
                    const log = plog.sub("input_item");
                    // FIXME implement all string constrains here
                    const v = await prompts.input_string("", { allow_empty: true });
                    return cb.ok(v);
                }
            }
        }
    }

    async function skip_or_input<R>(field: string, input_cb: () => Promise<R>): Promise<R | undefined> {
        const v = await prompts.input_string_enum(field, ["skip", "input"]);
        if (v === "input") {
            return input_cb();
        } else {
            return undefined;
        }
    }
}
