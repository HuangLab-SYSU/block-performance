// auto generated by dev/system

import { Logger } from "../../../myutils/logger.js";

export interface Input {
    sort?: {
        field_list: {
            id?: { order: "ascending" | "descending" };
            fake?: { order: "ascending" | "descending" };
            create_time?: { order: "ascending" | "descending" };
            update_time?: { order: "ascending" | "descending" };
            finger?: { order: "ascending" | "descending" };
            token?: { order: "ascending" | "descending" };
            username?: { order: "ascending" | "descending" };
            password?: { order: "ascending" | "descending" };
            avatar_url?: { order: "ascending" | "descending" };
            real_name?: { order: "ascending" | "descending" };
            gender?: { order: "ascending" | "descending" };
            birthday?: { order: "ascending" | "descending" };
            email?: { order: "ascending" | "descending" };
            phone_number_country_code?: { order: "ascending" | "descending" };
            phone_number?: { order: "ascending" | "descending" };
        }[];
    };
    page?: { offset: number; limit: number };
}

export interface OutputEmpty {
    list: {
        id: string;
        fake?: boolean;
        create_time: string;
        update_time: string;
        finger: string;
        token: string;
        username: string;
        password: string;
        avatar_url: string;
        real_name: string;
        gender: "unknown" | "male" | "female";
        birthday: string;
        email: string;
        phone_number_country_code: string;
        phone_number: string;
    }[];
    total_count: number;
}

export interface OutputOk {
    list: {
        id: string;
        fake?: boolean;
        create_time: string;
        update_time: string;
        finger: string;
        token: string;
        username: string;
        password: string;
        avatar_url: string;
        real_name: string;
        gender: "unknown" | "male" | "female";
        birthday: string;
        email: string;
        phone_number_country_code: string;
        phone_number: string;
    }[];
    total_count: number;
}

export interface OutputFail {}

export interface Callback<R> {
    empty: (output: OutputEmpty) => R;
    ok: (output: OutputOk) => R;
    fail: (err: Error) => R;
}

export function check_input<R>(plog: Logger, v: any, cb: { ok: () => R; fail: (err: Error) => R }): R {
    const log = plog.sub("check_input");
    log.variable("v", v);
    try {
        log.println("v must be object");
        if (typeof v !== "object" || v === null) {
            throw new Error("v is not object");
        }

        Object.keys(v).forEach((field) => {
            if (field === "sort") return;
            if (field === "page") return;
            throw new Error("v contains unknown field: " + field);
        });

        if (v.sort !== undefined) {
            log.println("v.sort must be object");
            if (typeof v.sort !== "object" || v.sort === null) {
                throw new Error("v.sort is not object");
            }

            Object.keys(v.sort).forEach((field) => {
                if (field === "field_list") return;
                throw new Error("v.sort contains unknown field: " + field);
            });

            log.println("v.sort.field_list must be array");
            if (!Array.isArray(v.sort.field_list)) {
                throw new Error("v.sort.field_list is not array");
            }

            v.sort.field_list.forEach((item: any, i: number) => {
                log.println("check v.sort.field_list[i]");

                log.println("item must be object");
                if (typeof item !== "object" || item === null) {
                    throw new Error("item is not object");
                }

                Object.keys(item).forEach((field) => {
                    if (field === "id") return;
                    if (field === "fake") return;
                    if (field === "create_time") return;
                    if (field === "update_time") return;
                    if (field === "finger") return;
                    if (field === "token") return;
                    if (field === "username") return;
                    if (field === "password") return;
                    if (field === "avatar_url") return;
                    if (field === "real_name") return;
                    if (field === "gender") return;
                    if (field === "birthday") return;
                    if (field === "email") return;
                    if (field === "phone_number_country_code") return;
                    if (field === "phone_number") return;
                    throw new Error("item contains unknown field: " + field);
                });

                if (item.id !== undefined) {
                    log.println("item.id must be object");
                    if (typeof item.id !== "object" || item.id === null) {
                        throw new Error("item.id is not object");
                    }

                    Object.keys(item.id).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.id contains unknown field: " + field);
                    });

                    log.println("item.id.order must be string");
                    if (typeof item.id.order !== "string") {
                        throw new Error("item.id.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.id.order) === false) {
                        throw new Error("item.id.order is not a valid string enum value");
                    }
                }

                if (item.fake !== undefined) {
                    log.println("item.fake must be object");
                    if (typeof item.fake !== "object" || item.fake === null) {
                        throw new Error("item.fake is not object");
                    }

                    Object.keys(item.fake).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.fake contains unknown field: " + field);
                    });

                    log.println("item.fake.order must be string");
                    if (typeof item.fake.order !== "string") {
                        throw new Error("item.fake.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.fake.order) === false) {
                        throw new Error("item.fake.order is not a valid string enum value");
                    }
                }

                if (item.create_time !== undefined) {
                    log.println("item.create_time must be object");
                    if (typeof item.create_time !== "object" || item.create_time === null) {
                        throw new Error("item.create_time is not object");
                    }

                    Object.keys(item.create_time).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.create_time contains unknown field: " + field);
                    });

                    log.println("item.create_time.order must be string");
                    if (typeof item.create_time.order !== "string") {
                        throw new Error("item.create_time.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.create_time.order) === false) {
                        throw new Error("item.create_time.order is not a valid string enum value");
                    }
                }

                if (item.update_time !== undefined) {
                    log.println("item.update_time must be object");
                    if (typeof item.update_time !== "object" || item.update_time === null) {
                        throw new Error("item.update_time is not object");
                    }

                    Object.keys(item.update_time).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.update_time contains unknown field: " + field);
                    });

                    log.println("item.update_time.order must be string");
                    if (typeof item.update_time.order !== "string") {
                        throw new Error("item.update_time.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.update_time.order) === false) {
                        throw new Error("item.update_time.order is not a valid string enum value");
                    }
                }

                if (item.finger !== undefined) {
                    log.println("item.finger must be object");
                    if (typeof item.finger !== "object" || item.finger === null) {
                        throw new Error("item.finger is not object");
                    }

                    Object.keys(item.finger).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.finger contains unknown field: " + field);
                    });

                    log.println("item.finger.order must be string");
                    if (typeof item.finger.order !== "string") {
                        throw new Error("item.finger.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.finger.order) === false) {
                        throw new Error("item.finger.order is not a valid string enum value");
                    }
                }

                if (item.token !== undefined) {
                    log.println("item.token must be object");
                    if (typeof item.token !== "object" || item.token === null) {
                        throw new Error("item.token is not object");
                    }

                    Object.keys(item.token).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.token contains unknown field: " + field);
                    });

                    log.println("item.token.order must be string");
                    if (typeof item.token.order !== "string") {
                        throw new Error("item.token.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.token.order) === false) {
                        throw new Error("item.token.order is not a valid string enum value");
                    }
                }

                if (item.username !== undefined) {
                    log.println("item.username must be object");
                    if (typeof item.username !== "object" || item.username === null) {
                        throw new Error("item.username is not object");
                    }

                    Object.keys(item.username).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.username contains unknown field: " + field);
                    });

                    log.println("item.username.order must be string");
                    if (typeof item.username.order !== "string") {
                        throw new Error("item.username.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.username.order) === false) {
                        throw new Error("item.username.order is not a valid string enum value");
                    }
                }

                if (item.password !== undefined) {
                    log.println("item.password must be object");
                    if (typeof item.password !== "object" || item.password === null) {
                        throw new Error("item.password is not object");
                    }

                    Object.keys(item.password).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.password contains unknown field: " + field);
                    });

                    log.println("item.password.order must be string");
                    if (typeof item.password.order !== "string") {
                        throw new Error("item.password.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.password.order) === false) {
                        throw new Error("item.password.order is not a valid string enum value");
                    }
                }

                if (item.avatar_url !== undefined) {
                    log.println("item.avatar_url must be object");
                    if (typeof item.avatar_url !== "object" || item.avatar_url === null) {
                        throw new Error("item.avatar_url is not object");
                    }

                    Object.keys(item.avatar_url).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.avatar_url contains unknown field: " + field);
                    });

                    log.println("item.avatar_url.order must be string");
                    if (typeof item.avatar_url.order !== "string") {
                        throw new Error("item.avatar_url.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.avatar_url.order) === false) {
                        throw new Error("item.avatar_url.order is not a valid string enum value");
                    }
                }

                if (item.real_name !== undefined) {
                    log.println("item.real_name must be object");
                    if (typeof item.real_name !== "object" || item.real_name === null) {
                        throw new Error("item.real_name is not object");
                    }

                    Object.keys(item.real_name).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.real_name contains unknown field: " + field);
                    });

                    log.println("item.real_name.order must be string");
                    if (typeof item.real_name.order !== "string") {
                        throw new Error("item.real_name.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.real_name.order) === false) {
                        throw new Error("item.real_name.order is not a valid string enum value");
                    }
                }

                if (item.gender !== undefined) {
                    log.println("item.gender must be object");
                    if (typeof item.gender !== "object" || item.gender === null) {
                        throw new Error("item.gender is not object");
                    }

                    Object.keys(item.gender).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.gender contains unknown field: " + field);
                    });

                    log.println("item.gender.order must be string");
                    if (typeof item.gender.order !== "string") {
                        throw new Error("item.gender.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.gender.order) === false) {
                        throw new Error("item.gender.order is not a valid string enum value");
                    }
                }

                if (item.birthday !== undefined) {
                    log.println("item.birthday must be object");
                    if (typeof item.birthday !== "object" || item.birthday === null) {
                        throw new Error("item.birthday is not object");
                    }

                    Object.keys(item.birthday).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.birthday contains unknown field: " + field);
                    });

                    log.println("item.birthday.order must be string");
                    if (typeof item.birthday.order !== "string") {
                        throw new Error("item.birthday.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.birthday.order) === false) {
                        throw new Error("item.birthday.order is not a valid string enum value");
                    }
                }

                if (item.email !== undefined) {
                    log.println("item.email must be object");
                    if (typeof item.email !== "object" || item.email === null) {
                        throw new Error("item.email is not object");
                    }

                    Object.keys(item.email).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.email contains unknown field: " + field);
                    });

                    log.println("item.email.order must be string");
                    if (typeof item.email.order !== "string") {
                        throw new Error("item.email.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.email.order) === false) {
                        throw new Error("item.email.order is not a valid string enum value");
                    }
                }

                if (item.phone_number_country_code !== undefined) {
                    log.println("item.phone_number_country_code must be object");
                    if (typeof item.phone_number_country_code !== "object" || item.phone_number_country_code === null) {
                        throw new Error("item.phone_number_country_code is not object");
                    }

                    Object.keys(item.phone_number_country_code).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.phone_number_country_code contains unknown field: " + field);
                    });

                    log.println("item.phone_number_country_code.order must be string");
                    if (typeof item.phone_number_country_code.order !== "string") {
                        throw new Error("item.phone_number_country_code.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.phone_number_country_code.order) === false) {
                        throw new Error("item.phone_number_country_code.order is not a valid string enum value");
                    }
                }

                if (item.phone_number !== undefined) {
                    log.println("item.phone_number must be object");
                    if (typeof item.phone_number !== "object" || item.phone_number === null) {
                        throw new Error("item.phone_number is not object");
                    }

                    Object.keys(item.phone_number).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.phone_number contains unknown field: " + field);
                    });

                    log.println("item.phone_number.order must be string");
                    if (typeof item.phone_number.order !== "string") {
                        throw new Error("item.phone_number.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.phone_number.order) === false) {
                        throw new Error("item.phone_number.order is not a valid string enum value");
                    }
                }
            });
        }

        if (v.page !== undefined) {
            log.println("v.page must be object");
            if (typeof v.page !== "object" || v.page === null) {
                throw new Error("v.page is not object");
            }

            Object.keys(v.page).forEach((field) => {
                if (field === "offset") return;
                if (field === "limit") return;
                throw new Error("v.page contains unknown field: " + field);
            });

            log.println("v.page.offset must be number");
            if (typeof v.page.offset !== "number") {
                throw new Error("v.page.offset is not number");
            }

            if (Number.isSafeInteger(v.page.offset) === false) {
                throw new Error("v.page.offset is not safe integer");
            }

            if ((v.page.offset >= 0 && v.page.offset < 9007199254740991) === false) {
                throw new Error("v.page.offset is out of range");
            }

            log.println("v.page.limit must be number");
            if (typeof v.page.limit !== "number") {
                throw new Error("v.page.limit is not number");
            }

            if (Number.isSafeInteger(v.page.limit) === false) {
                throw new Error("v.page.limit is not safe integer");
            }

            if ((v.page.limit >= 0 && v.page.limit < 9007199254740991) === false) {
                throw new Error("v.page.limit is out of range");
            }
        }
    } catch (err) {
        log.error(err);
        return cb.fail(err);
    }
    // nothing wrong
    log.ok();
    return cb.ok();
}

// JSON stringify value before copy to handle some specific problem
// eg. Date Object probelm
export function copy_output_empty(v: any): OutputEmpty {
    if (v !== undefined) {
        const v_cloned = JSON.parse(JSON.stringify(v));
        return _copy_output_empty(v_cloned);
    } else {
        return _copy_output_empty(v);
    }
}

export function _copy_output_empty(v: any): OutputEmpty {
    if (typeof v === "object" && v !== null) {
        const obj = {
            list: copy_list(v.list),
            total_count: copy_total_count(v.total_count)
        };
        return obj;
    } else {
        return { list: [], total_count: 0 };
    }

    function copy_list(
        v: any
    ): {
        id: string;
        fake?: boolean;
        create_time: string;
        update_time: string;
        finger: string;
        token: string;
        username: string;
        password: string;
        avatar_url: string;
        real_name: string;
        gender: "unknown" | "male" | "female";
        birthday: string;
        email: string;
        phone_number_country_code: string;
        phone_number: string;
    }[] {
        return Array.isArray(v) ? v.map(copy_item) : [];

        function copy_item(v: any): {
            id: string;
            fake?: boolean;
            create_time: string;
            update_time: string;
            finger: string;
            token: string;
            username: string;
            password: string;
            avatar_url: string;
            real_name: string;
            gender: "unknown" | "male" | "female";
            birthday: string;
            email: string;
            phone_number_country_code: string;
            phone_number: string;
        } {
            if (typeof v === "object" && v !== null) {
                const obj = {
                    id: copy_id(v.id),
                    fake: v.fake !== undefined && v.fake !== null ? copy_fake(v.fake) : undefined,
                    create_time: copy_create_time(v.create_time),
                    update_time: copy_update_time(v.update_time),
                    finger: copy_finger(v.finger),
                    token: copy_token(v.token),
                    username: copy_username(v.username),
                    password: copy_password(v.password),
                    avatar_url: copy_avatar_url(v.avatar_url),
                    real_name: copy_real_name(v.real_name),
                    gender: copy_gender(v.gender),
                    birthday: copy_birthday(v.birthday),
                    email: copy_email(v.email),
                    phone_number_country_code: copy_phone_number_country_code(v.phone_number_country_code),
                    phone_number: copy_phone_number(v.phone_number)
                };
                return obj;
            } else {
                return {
                    id: "",
                    create_time: "",
                    update_time: "",
                    finger: "",
                    token: "",
                    username: "",
                    password: "",
                    avatar_url: "",
                    real_name: "",
                    gender: "unknown",
                    birthday: "",
                    email: "",
                    phone_number_country_code: "",
                    phone_number: ""
                };
            }

            function copy_id(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_fake(v: any): boolean {
                return typeof v === "boolean" ? v : false;
            }

            function copy_create_time(v: any): string {
                // empty datetime value is acceptable
                if (typeof v !== "string") {
                    return "";
                } else {
                    if (v === "") {
                        return v;
                    } else if (Number.isNaN(Date.parse(v)) === false) {
                        return v;
                    } else {
                        // invalid value, return empty string
                        return "";
                    }
                }
            }

            function copy_update_time(v: any): string {
                // empty datetime value is acceptable
                if (typeof v !== "string") {
                    return "";
                } else {
                    if (v === "") {
                        return v;
                    } else if (Number.isNaN(Date.parse(v)) === false) {
                        return v;
                    } else {
                        // invalid value, return empty string
                        return "";
                    }
                }
            }

            function copy_finger(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_token(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_username(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_password(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_avatar_url(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_real_name(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_gender(v: any): "unknown" | "male" | "female" {
                if (typeof v === "string" && new Set(["unknown", "male", "female"]).has(v) === true) {
                    return v as any;
                } else {
                    return "unknown" as any;
                }
            }

            function copy_birthday(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_email(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_phone_number_country_code(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_phone_number(v: any): string {
                return typeof v === "string" ? v : "";
            }
        }
    }

    function copy_total_count(v: any): number {
        return typeof v === "number" ? v : 0;
    }
}

// JSON stringify value before copy to handle some specific problem
// eg. Date Object probelm
export function copy_output_ok(v: any): OutputOk {
    if (v !== undefined) {
        const v_cloned = JSON.parse(JSON.stringify(v));
        return _copy_output_ok(v_cloned);
    } else {
        return _copy_output_ok(v);
    }
}

export function _copy_output_ok(v: any): OutputOk {
    if (typeof v === "object" && v !== null) {
        const obj = {
            list: copy_list(v.list),
            total_count: copy_total_count(v.total_count)
        };
        return obj;
    } else {
        return { list: [], total_count: 0 };
    }

    function copy_list(
        v: any
    ): {
        id: string;
        fake?: boolean;
        create_time: string;
        update_time: string;
        finger: string;
        token: string;
        username: string;
        password: string;
        avatar_url: string;
        real_name: string;
        gender: "unknown" | "male" | "female";
        birthday: string;
        email: string;
        phone_number_country_code: string;
        phone_number: string;
    }[] {
        return Array.isArray(v) ? v.map(copy_item) : [];

        function copy_item(v: any): {
            id: string;
            fake?: boolean;
            create_time: string;
            update_time: string;
            finger: string;
            token: string;
            username: string;
            password: string;
            avatar_url: string;
            real_name: string;
            gender: "unknown" | "male" | "female";
            birthday: string;
            email: string;
            phone_number_country_code: string;
            phone_number: string;
        } {
            if (typeof v === "object" && v !== null) {
                const obj = {
                    id: copy_id(v.id),
                    fake: v.fake !== undefined && v.fake !== null ? copy_fake(v.fake) : undefined,
                    create_time: copy_create_time(v.create_time),
                    update_time: copy_update_time(v.update_time),
                    finger: copy_finger(v.finger),
                    token: copy_token(v.token),
                    username: copy_username(v.username),
                    password: copy_password(v.password),
                    avatar_url: copy_avatar_url(v.avatar_url),
                    real_name: copy_real_name(v.real_name),
                    gender: copy_gender(v.gender),
                    birthday: copy_birthday(v.birthday),
                    email: copy_email(v.email),
                    phone_number_country_code: copy_phone_number_country_code(v.phone_number_country_code),
                    phone_number: copy_phone_number(v.phone_number)
                };
                return obj;
            } else {
                return {
                    id: "",
                    create_time: "",
                    update_time: "",
                    finger: "",
                    token: "",
                    username: "",
                    password: "",
                    avatar_url: "",
                    real_name: "",
                    gender: "unknown",
                    birthday: "",
                    email: "",
                    phone_number_country_code: "",
                    phone_number: ""
                };
            }

            function copy_id(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_fake(v: any): boolean {
                return typeof v === "boolean" ? v : false;
            }

            function copy_create_time(v: any): string {
                // empty datetime value is acceptable
                if (typeof v !== "string") {
                    return "";
                } else {
                    if (v === "") {
                        return v;
                    } else if (Number.isNaN(Date.parse(v)) === false) {
                        return v;
                    } else {
                        // invalid value, return empty string
                        return "";
                    }
                }
            }

            function copy_update_time(v: any): string {
                // empty datetime value is acceptable
                if (typeof v !== "string") {
                    return "";
                } else {
                    if (v === "") {
                        return v;
                    } else if (Number.isNaN(Date.parse(v)) === false) {
                        return v;
                    } else {
                        // invalid value, return empty string
                        return "";
                    }
                }
            }

            function copy_finger(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_token(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_username(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_password(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_avatar_url(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_real_name(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_gender(v: any): "unknown" | "male" | "female" {
                if (typeof v === "string" && new Set(["unknown", "male", "female"]).has(v) === true) {
                    return v as any;
                } else {
                    return "unknown" as any;
                }
            }

            function copy_birthday(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_email(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_phone_number_country_code(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_phone_number(v: any): string {
                return typeof v === "string" ? v : "";
            }
        }
    }

    function copy_total_count(v: any): number {
        return typeof v === "number" ? v : 0;
    }
}

// backward compatible purpose
export type Output = OutputOk;
export const copy_output = copy_output_ok;
