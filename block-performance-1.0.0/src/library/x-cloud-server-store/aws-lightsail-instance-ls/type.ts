// auto generated by dev/system

import { Logger } from "../../../myutils/logger.js";

export interface Input {
    sort?: {
        field_list: {
            id?: { order: "ascending" | "descending" };
            fake?: { order: "ascending" | "descending" };
            create_time?: { order: "ascending" | "descending" };
            update_time?: { order: "ascending" | "descending" };
            region?: { order: "ascending" | "descending" };
            availability_zone?: { order: "ascending" | "descending" };
            instance_name?: { order: "ascending" | "descending" };
            blueprint_id?: { order: "ascending" | "descending" };
            bundle_id?: { order: "ascending" | "descending" };
            ssh_username?: { order: "ascending" | "descending" };
            address_ipv4?: { order: "ascending" | "descending" };
            address_ipv6?: { order: "ascending" | "descending" };
        }[];
    };
    page?: { offset: number; limit: number };
}

export interface OutputEmpty {
    list: {
        id: string;
        fake?: boolean;
        create_time: string;
        update_time: string;
        region: string;
        availability_zone: string;
        instance_name: string;
        blueprint_id: string;
        bundle_id: string;
        ssh_username: string;
        address_ipv4: string;
        address_ipv6: string;
    }[];
    total_count: number;
}

export interface OutputOk {
    list: {
        id: string;
        fake?: boolean;
        create_time: string;
        update_time: string;
        region: string;
        availability_zone: string;
        instance_name: string;
        blueprint_id: string;
        bundle_id: string;
        ssh_username: string;
        address_ipv4: string;
        address_ipv6: string;
    }[];
    total_count: number;
}

export interface OutputFail {}

export interface Callback<R> {
    empty: (output: OutputEmpty) => R;
    ok: (output: OutputOk) => R;
    fail: (err: Error) => R;
}

export function check_input<R>(plog: Logger, v: any, cb: { ok: () => R; fail: (err: Error) => R }): R {
    const log = plog.sub("check_input");
    log.variable("v", v);
    try {
        log.println("v must be object");
        if (typeof v !== "object" || v === null) {
            throw new Error("v is not object");
        }

        Object.keys(v).forEach((field) => {
            if (field === "sort") return;
            if (field === "page") return;
            throw new Error("v contains unknown field: " + field);
        });

        if (v.sort !== undefined) {
            log.println("v.sort must be object");
            if (typeof v.sort !== "object" || v.sort === null) {
                throw new Error("v.sort is not object");
            }

            Object.keys(v.sort).forEach((field) => {
                if (field === "field_list") return;
                throw new Error("v.sort contains unknown field: " + field);
            });

            log.println("v.sort.field_list must be array");
            if (!Array.isArray(v.sort.field_list)) {
                throw new Error("v.sort.field_list is not array");
            }

            v.sort.field_list.forEach((item: any, i: number) => {
                log.println("check v.sort.field_list[i]");

                log.println("item must be object");
                if (typeof item !== "object" || item === null) {
                    throw new Error("item is not object");
                }

                Object.keys(item).forEach((field) => {
                    if (field === "id") return;
                    if (field === "fake") return;
                    if (field === "create_time") return;
                    if (field === "update_time") return;
                    if (field === "region") return;
                    if (field === "availability_zone") return;
                    if (field === "instance_name") return;
                    if (field === "blueprint_id") return;
                    if (field === "bundle_id") return;
                    if (field === "ssh_username") return;
                    if (field === "address_ipv4") return;
                    if (field === "address_ipv6") return;
                    throw new Error("item contains unknown field: " + field);
                });

                if (item.id !== undefined) {
                    log.println("item.id must be object");
                    if (typeof item.id !== "object" || item.id === null) {
                        throw new Error("item.id is not object");
                    }

                    Object.keys(item.id).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.id contains unknown field: " + field);
                    });

                    log.println("item.id.order must be string");
                    if (typeof item.id.order !== "string") {
                        throw new Error("item.id.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.id.order) === false) {
                        throw new Error("item.id.order is not a valid string enum value");
                    }
                }

                if (item.fake !== undefined) {
                    log.println("item.fake must be object");
                    if (typeof item.fake !== "object" || item.fake === null) {
                        throw new Error("item.fake is not object");
                    }

                    Object.keys(item.fake).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.fake contains unknown field: " + field);
                    });

                    log.println("item.fake.order must be string");
                    if (typeof item.fake.order !== "string") {
                        throw new Error("item.fake.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.fake.order) === false) {
                        throw new Error("item.fake.order is not a valid string enum value");
                    }
                }

                if (item.create_time !== undefined) {
                    log.println("item.create_time must be object");
                    if (typeof item.create_time !== "object" || item.create_time === null) {
                        throw new Error("item.create_time is not object");
                    }

                    Object.keys(item.create_time).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.create_time contains unknown field: " + field);
                    });

                    log.println("item.create_time.order must be string");
                    if (typeof item.create_time.order !== "string") {
                        throw new Error("item.create_time.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.create_time.order) === false) {
                        throw new Error("item.create_time.order is not a valid string enum value");
                    }
                }

                if (item.update_time !== undefined) {
                    log.println("item.update_time must be object");
                    if (typeof item.update_time !== "object" || item.update_time === null) {
                        throw new Error("item.update_time is not object");
                    }

                    Object.keys(item.update_time).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.update_time contains unknown field: " + field);
                    });

                    log.println("item.update_time.order must be string");
                    if (typeof item.update_time.order !== "string") {
                        throw new Error("item.update_time.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.update_time.order) === false) {
                        throw new Error("item.update_time.order is not a valid string enum value");
                    }
                }

                if (item.region !== undefined) {
                    log.println("item.region must be object");
                    if (typeof item.region !== "object" || item.region === null) {
                        throw new Error("item.region is not object");
                    }

                    Object.keys(item.region).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.region contains unknown field: " + field);
                    });

                    log.println("item.region.order must be string");
                    if (typeof item.region.order !== "string") {
                        throw new Error("item.region.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.region.order) === false) {
                        throw new Error("item.region.order is not a valid string enum value");
                    }
                }

                if (item.availability_zone !== undefined) {
                    log.println("item.availability_zone must be object");
                    if (typeof item.availability_zone !== "object" || item.availability_zone === null) {
                        throw new Error("item.availability_zone is not object");
                    }

                    Object.keys(item.availability_zone).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.availability_zone contains unknown field: " + field);
                    });

                    log.println("item.availability_zone.order must be string");
                    if (typeof item.availability_zone.order !== "string") {
                        throw new Error("item.availability_zone.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.availability_zone.order) === false) {
                        throw new Error("item.availability_zone.order is not a valid string enum value");
                    }
                }

                if (item.instance_name !== undefined) {
                    log.println("item.instance_name must be object");
                    if (typeof item.instance_name !== "object" || item.instance_name === null) {
                        throw new Error("item.instance_name is not object");
                    }

                    Object.keys(item.instance_name).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.instance_name contains unknown field: " + field);
                    });

                    log.println("item.instance_name.order must be string");
                    if (typeof item.instance_name.order !== "string") {
                        throw new Error("item.instance_name.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.instance_name.order) === false) {
                        throw new Error("item.instance_name.order is not a valid string enum value");
                    }
                }

                if (item.blueprint_id !== undefined) {
                    log.println("item.blueprint_id must be object");
                    if (typeof item.blueprint_id !== "object" || item.blueprint_id === null) {
                        throw new Error("item.blueprint_id is not object");
                    }

                    Object.keys(item.blueprint_id).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.blueprint_id contains unknown field: " + field);
                    });

                    log.println("item.blueprint_id.order must be string");
                    if (typeof item.blueprint_id.order !== "string") {
                        throw new Error("item.blueprint_id.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.blueprint_id.order) === false) {
                        throw new Error("item.blueprint_id.order is not a valid string enum value");
                    }
                }

                if (item.bundle_id !== undefined) {
                    log.println("item.bundle_id must be object");
                    if (typeof item.bundle_id !== "object" || item.bundle_id === null) {
                        throw new Error("item.bundle_id is not object");
                    }

                    Object.keys(item.bundle_id).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.bundle_id contains unknown field: " + field);
                    });

                    log.println("item.bundle_id.order must be string");
                    if (typeof item.bundle_id.order !== "string") {
                        throw new Error("item.bundle_id.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.bundle_id.order) === false) {
                        throw new Error("item.bundle_id.order is not a valid string enum value");
                    }
                }

                if (item.ssh_username !== undefined) {
                    log.println("item.ssh_username must be object");
                    if (typeof item.ssh_username !== "object" || item.ssh_username === null) {
                        throw new Error("item.ssh_username is not object");
                    }

                    Object.keys(item.ssh_username).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.ssh_username contains unknown field: " + field);
                    });

                    log.println("item.ssh_username.order must be string");
                    if (typeof item.ssh_username.order !== "string") {
                        throw new Error("item.ssh_username.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.ssh_username.order) === false) {
                        throw new Error("item.ssh_username.order is not a valid string enum value");
                    }
                }

                if (item.address_ipv4 !== undefined) {
                    log.println("item.address_ipv4 must be object");
                    if (typeof item.address_ipv4 !== "object" || item.address_ipv4 === null) {
                        throw new Error("item.address_ipv4 is not object");
                    }

                    Object.keys(item.address_ipv4).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.address_ipv4 contains unknown field: " + field);
                    });

                    log.println("item.address_ipv4.order must be string");
                    if (typeof item.address_ipv4.order !== "string") {
                        throw new Error("item.address_ipv4.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.address_ipv4.order) === false) {
                        throw new Error("item.address_ipv4.order is not a valid string enum value");
                    }
                }

                if (item.address_ipv6 !== undefined) {
                    log.println("item.address_ipv6 must be object");
                    if (typeof item.address_ipv6 !== "object" || item.address_ipv6 === null) {
                        throw new Error("item.address_ipv6 is not object");
                    }

                    Object.keys(item.address_ipv6).forEach((field) => {
                        if (field === "order") return;
                        throw new Error("item.address_ipv6 contains unknown field: " + field);
                    });

                    log.println("item.address_ipv6.order must be string");
                    if (typeof item.address_ipv6.order !== "string") {
                        throw new Error("item.address_ipv6.order is not string");
                    }

                    if (new Set(["ascending", "descending"]).has(item.address_ipv6.order) === false) {
                        throw new Error("item.address_ipv6.order is not a valid string enum value");
                    }
                }
            });
        }

        if (v.page !== undefined) {
            log.println("v.page must be object");
            if (typeof v.page !== "object" || v.page === null) {
                throw new Error("v.page is not object");
            }

            Object.keys(v.page).forEach((field) => {
                if (field === "offset") return;
                if (field === "limit") return;
                throw new Error("v.page contains unknown field: " + field);
            });

            log.println("v.page.offset must be number");
            if (typeof v.page.offset !== "number") {
                throw new Error("v.page.offset is not number");
            }

            if (Number.isSafeInteger(v.page.offset) === false) {
                throw new Error("v.page.offset is not safe integer");
            }

            if ((v.page.offset >= 0 && v.page.offset < 9007199254740991) === false) {
                throw new Error("v.page.offset is out of range");
            }

            log.println("v.page.limit must be number");
            if (typeof v.page.limit !== "number") {
                throw new Error("v.page.limit is not number");
            }

            if (Number.isSafeInteger(v.page.limit) === false) {
                throw new Error("v.page.limit is not safe integer");
            }

            if ((v.page.limit >= 0 && v.page.limit < 9007199254740991) === false) {
                throw new Error("v.page.limit is out of range");
            }
        }
    } catch (err) {
        log.error(err);
        return cb.fail(err);
    }
    // nothing wrong
    log.ok();
    return cb.ok();
}

// JSON stringify value before copy to handle some specific problem
// eg. Date Object probelm
export function copy_output_empty(v: any): OutputEmpty {
    if (v !== undefined) {
        const v_cloned = JSON.parse(JSON.stringify(v));
        return _copy_output_empty(v_cloned);
    } else {
        return _copy_output_empty(v);
    }
}

export function _copy_output_empty(v: any): OutputEmpty {
    if (typeof v === "object" && v !== null) {
        const obj = {
            list: copy_list(v.list),
            total_count: copy_total_count(v.total_count)
        };
        return obj;
    } else {
        return { list: [], total_count: 0 };
    }

    function copy_list(
        v: any
    ): {
        id: string;
        fake?: boolean;
        create_time: string;
        update_time: string;
        region: string;
        availability_zone: string;
        instance_name: string;
        blueprint_id: string;
        bundle_id: string;
        ssh_username: string;
        address_ipv4: string;
        address_ipv6: string;
    }[] {
        return Array.isArray(v) ? v.map(copy_item) : [];

        function copy_item(v: any): {
            id: string;
            fake?: boolean;
            create_time: string;
            update_time: string;
            region: string;
            availability_zone: string;
            instance_name: string;
            blueprint_id: string;
            bundle_id: string;
            ssh_username: string;
            address_ipv4: string;
            address_ipv6: string;
        } {
            if (typeof v === "object" && v !== null) {
                const obj = {
                    id: copy_id(v.id),
                    fake: v.fake !== undefined && v.fake !== null ? copy_fake(v.fake) : undefined,
                    create_time: copy_create_time(v.create_time),
                    update_time: copy_update_time(v.update_time),
                    region: copy_region(v.region),
                    availability_zone: copy_availability_zone(v.availability_zone),
                    instance_name: copy_instance_name(v.instance_name),
                    blueprint_id: copy_blueprint_id(v.blueprint_id),
                    bundle_id: copy_bundle_id(v.bundle_id),
                    ssh_username: copy_ssh_username(v.ssh_username),
                    address_ipv4: copy_address_ipv4(v.address_ipv4),
                    address_ipv6: copy_address_ipv6(v.address_ipv6)
                };
                return obj;
            } else {
                return {
                    id: "",
                    create_time: "",
                    update_time: "",
                    region: "",
                    availability_zone: "",
                    instance_name: "",
                    blueprint_id: "",
                    bundle_id: "",
                    ssh_username: "",
                    address_ipv4: "",
                    address_ipv6: ""
                };
            }

            function copy_id(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_fake(v: any): boolean {
                return typeof v === "boolean" ? v : false;
            }

            function copy_create_time(v: any): string {
                // empty datetime value is acceptable
                if (typeof v !== "string") {
                    return "";
                } else {
                    if (v === "") {
                        return v;
                    } else if (Number.isNaN(Date.parse(v)) === false) {
                        return v;
                    } else {
                        // invalid value, return empty string
                        return "";
                    }
                }
            }

            function copy_update_time(v: any): string {
                // empty datetime value is acceptable
                if (typeof v !== "string") {
                    return "";
                } else {
                    if (v === "") {
                        return v;
                    } else if (Number.isNaN(Date.parse(v)) === false) {
                        return v;
                    } else {
                        // invalid value, return empty string
                        return "";
                    }
                }
            }

            function copy_region(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_availability_zone(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_instance_name(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_blueprint_id(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_bundle_id(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_ssh_username(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_address_ipv4(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_address_ipv6(v: any): string {
                return typeof v === "string" ? v : "";
            }
        }
    }

    function copy_total_count(v: any): number {
        return typeof v === "number" ? v : 0;
    }
}

// JSON stringify value before copy to handle some specific problem
// eg. Date Object probelm
export function copy_output_ok(v: any): OutputOk {
    if (v !== undefined) {
        const v_cloned = JSON.parse(JSON.stringify(v));
        return _copy_output_ok(v_cloned);
    } else {
        return _copy_output_ok(v);
    }
}

export function _copy_output_ok(v: any): OutputOk {
    if (typeof v === "object" && v !== null) {
        const obj = {
            list: copy_list(v.list),
            total_count: copy_total_count(v.total_count)
        };
        return obj;
    } else {
        return { list: [], total_count: 0 };
    }

    function copy_list(
        v: any
    ): {
        id: string;
        fake?: boolean;
        create_time: string;
        update_time: string;
        region: string;
        availability_zone: string;
        instance_name: string;
        blueprint_id: string;
        bundle_id: string;
        ssh_username: string;
        address_ipv4: string;
        address_ipv6: string;
    }[] {
        return Array.isArray(v) ? v.map(copy_item) : [];

        function copy_item(v: any): {
            id: string;
            fake?: boolean;
            create_time: string;
            update_time: string;
            region: string;
            availability_zone: string;
            instance_name: string;
            blueprint_id: string;
            bundle_id: string;
            ssh_username: string;
            address_ipv4: string;
            address_ipv6: string;
        } {
            if (typeof v === "object" && v !== null) {
                const obj = {
                    id: copy_id(v.id),
                    fake: v.fake !== undefined && v.fake !== null ? copy_fake(v.fake) : undefined,
                    create_time: copy_create_time(v.create_time),
                    update_time: copy_update_time(v.update_time),
                    region: copy_region(v.region),
                    availability_zone: copy_availability_zone(v.availability_zone),
                    instance_name: copy_instance_name(v.instance_name),
                    blueprint_id: copy_blueprint_id(v.blueprint_id),
                    bundle_id: copy_bundle_id(v.bundle_id),
                    ssh_username: copy_ssh_username(v.ssh_username),
                    address_ipv4: copy_address_ipv4(v.address_ipv4),
                    address_ipv6: copy_address_ipv6(v.address_ipv6)
                };
                return obj;
            } else {
                return {
                    id: "",
                    create_time: "",
                    update_time: "",
                    region: "",
                    availability_zone: "",
                    instance_name: "",
                    blueprint_id: "",
                    bundle_id: "",
                    ssh_username: "",
                    address_ipv4: "",
                    address_ipv6: ""
                };
            }

            function copy_id(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_fake(v: any): boolean {
                return typeof v === "boolean" ? v : false;
            }

            function copy_create_time(v: any): string {
                // empty datetime value is acceptable
                if (typeof v !== "string") {
                    return "";
                } else {
                    if (v === "") {
                        return v;
                    } else if (Number.isNaN(Date.parse(v)) === false) {
                        return v;
                    } else {
                        // invalid value, return empty string
                        return "";
                    }
                }
            }

            function copy_update_time(v: any): string {
                // empty datetime value is acceptable
                if (typeof v !== "string") {
                    return "";
                } else {
                    if (v === "") {
                        return v;
                    } else if (Number.isNaN(Date.parse(v)) === false) {
                        return v;
                    } else {
                        // invalid value, return empty string
                        return "";
                    }
                }
            }

            function copy_region(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_availability_zone(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_instance_name(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_blueprint_id(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_bundle_id(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_ssh_username(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_address_ipv4(v: any): string {
                return typeof v === "string" ? v : "";
            }

            function copy_address_ipv6(v: any): string {
                return typeof v === "string" ? v : "";
            }
        }
    }

    function copy_total_count(v: any): number {
        return typeof v === "number" ? v : 0;
    }
}

// backward compatible purpose
export type Output = OutputOk;
export const copy_output = copy_output_ok;
